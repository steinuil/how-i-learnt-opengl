#pragma once

#include <math.h>

<% ops = [
  [ 'add', '+' ],
  [ 'sub', '-' ],
  [ 'mul', '*' ],
  [ 'div', '/' ]
] -%>

typedef struct { float x, y, z; } vec3_t;


static inline vec3_t vec3(float x, float y, float z) {
  return (vec3_t) { x, y, z };
}

// Scalar operations
<% ops.each do |name, op| -%>
vec3_t vec3_<%= name %>1(vec3_t v, float s) {
  return (vec3_t) { v.x <%= op %> s, v.y <%= op %> s, v.z <%= op %> s };
}
<% end -%>


// Negation
vec3_t vec3_negate(vec3_t v) {
  return (vec3_t) { -(v.x), -(v.y), -(v.z) };
}

float vec3_length(vec3_t v) {
  return (float) fabs(sqrt(
    v.x * v.x +
    v.y * v.y +
    v.z * v.z
  ));
}


// Vector on vector action
vec3_t vec3_add(vec3_t v, vec3_t k) {
  return (vec3_t) {
    v.x + k.x,
    v.y + k.y,
    v.z + k.z,
  };
}

vec3_t vec3_sub(vec3_t v, vec3_t k) {
  return (vec3_t) {
    v.x + (-(v.x)),
    v.y + (-(v.y)),
    v.z + (-(v.z)),
  };
}

float vec3_dot_product(vec3_t v, vec3_t k) {
  return (float) (
    (v.x * k.x) +
    (v.y * k.y) +
    (v.z * k.z)
  );
}

vec3_t vec3_mul(vec3_t v, vec3_t k) {
  return (vec3_t) {
    (v.y * k.z) - (v.z * k.y),
    (v.z * k.x) - (v.x * k.z),
    (v.x * k.y) - (v.y * k.x),
  };
}


// Matrices
<% def mat4() 4.times.map { |i| 4.times.map { |j| yield i, j } } end -%>
typedef struct {
<% mat4 do |i, j| -%>
  float m<%= i.to_s + j.to_s %>;
<% end -%>
} mat4_t;

static inline mat4_t mat4(<%= mat4 { |i, j| "float m#{j}#{i}" }.join ', ' %>) {
  return (mat4_t) { <%= mat4 { |i, j| "m#{i}#{j}" }.join ", " %> };
};

// Scalar operations
<% ops.take(3).each do |name, op| -%>
mat4_t mat4_<%= name %>1(mat4_t m, float s) {
  return (mat4_t) {
  <% mat4 do |i, j| -%>
    m.m<%= i.to_s + j.to_s %> <%= op %> s,
  <% end -%>
  };
}
<% end -%>

// Matrix on matrix
<% ops.take(2).each do |name, op| -%>
mat4_t mat4_<%= name %>(mat4_t m, mat4_t n) {
  return (mat4_t) {
  <% mat4 do |i, j| %><% curr = i.to_s + j.to_s -%>
    m.m<%= curr %> <%= op %> n.m<%= curr %>,
  <% end -%>
  };
}
<% end -%>

mat4_t mat4_mul(mat4_t m, mat4_t n) {
  return (mat4_t) {
  <% mat4 do |i, j| -%>
    <%= 4.times.map { |k| "m.m#{k}#{j} * n.m#{i}#{k}" }.join ' + ' %>,
  <% end -%>
  };
}


// Matrix on vector
mat4_t mat4_scale(vec3_t v) {
  return mat4(
    v.x, 0.0, 0.0, 0.0,
    0.0, v.y, 0.0, 0.0,
    0.0, 0.0, v.z, 0.0,
    0.0, 0.0, 0.0, 1.0
  );
}

mat4_t mat4_translate(vec3_t v) {
  return mat4(
    1.0, 0.0, 0.0, v.x,
    0.0, 1.0, 0.0, v.y,
    0.0, 0.0, 1.0, v.z,
    0.0, 0.0, 0.0, 1.0
  );
}

float deg_to_rad(float angle_deg) {
  return (float) (angle_deg * (M_PI / 180.0));
}

mat4_t mat4_rotate_x(float angle_rad) {
  float c = cosf(angle_rad), s = sinf(angle_rad);
  return mat4(
    1.0, 0.0, 0.0, 0.0,
    0.0,   c,  -s, 0.0,
    0.0,   s,   c, 0.0,
    0.0, 0.0, 0.0, 1.0
  );
}

mat4_t mat4_rotate_y(float angle_rad) {
  float c = cosf(angle_rad), s = sinf(angle_rad);
  return mat4(
      c, 0.0,   s, 0.0,
    0.0, 1.0, 0.0, 0.0,
     -s, 0.0,   c, 0.0,
    0.0, 0.0, 0.0, 1.0
  );
}

mat4_t mat4_rotate_z(float angle_rad) {
  float c = cosf(angle_rad), s = sinf(angle_rad);
  return mat4(
      c,  -s, 0.0, 0.0,
      s,   c, 0.0, 0.0,
    0.0, 0.0, 1.0, 0.0,
    0.0, 0.0, 0.0, 1.0
  );
}

static inline mat4_t vec3_to_mat4(vec3_t v) {
  return mat4(
    1.0, 0.0, 0.0, v.x,
    0.0, 1.0, 0.0, v.y,
    0.0, 0.0, 1.0, v.z,
    0.0, 0.0, 0.0, 1.0
  );
}

vec3_t vec3_transform(mat4_t m, vec3_t v) {
  mat4_t nv = mat4_mul(m, vec3_to_mat4(v));
  return (vec3_t) { nv.m30, nv.m31, nv.m32 };
}
